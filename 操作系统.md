# 1 操作系统

操作系统需要准备2~3个可以将半个小时左右时间的问题，备选：

1. 进程与线程的区别；
2. 操作系统的内存管理方式（物理地址、虚拟地址）；
3. 进程间通信；
4. task的切换过程；

## 1.1 进程与线程的区别

进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程是操作系统调度的最小单位，而进程是操作系统资源分配的最小单位。 

   **线程与进程的区别归纳：**   

   **a.地址空间和其它资源**：进程间相互独立，每个进程拥有独立的地址空间，一个进程无法访问其他进程的内存空间。同一进程的各线程间共享内存空间，一个进程内的线程对其他进程不可见。  

   **b.通信：**进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。  

   **c.调度和切换**：线程上下文切换比进程上下文切换要快得多。  

   d.在多线程OS中，进程不是一个可执行的实体。  





**以Linux为例解释上述区别：**



#### 1.1.1 在创建阶段，进程和线程的区别：

1. 概念上的进程和线程在Linux 中都是以一个名为 task_struct 的结构体来描述的。这个结构体中记录了所有相关信息。

   包括: 进程状态、pid、栈地址、文件系统环境、寄存器信息等等

2. 从进程和线程的创建上面解释两者的区别，主要是地址空间和资源的区别：


fork	        创造的子进程是父进程的完整副本，复制了父亲进程的资源，包括内存的内容task_struct内容
clone	Linux上创建线程一般使用的是pthread库 实际上linux也给我们提供了创建线程的系统调用

两者都会走到一个名为 do_fork 的函数，

**先说一下do_fork 的主要作用：**

do_fork 做的事情主要就是为新进程分配 task_struct 节点，然后调用 copy_process 将父进程的task_struct 信息复制过来，然后为新进程分配pid，初始化一些统计信息，根据传入参数采取一些不同的操作，然后就wake up 这个任务，最后这个任务就会等待被调度。

do_fork函数有一个 clone_flags 的参数，这个参数决定了在执行copy_process 的过程中采取哪些措施。主要包括：内存描述符和所有页表，工作目录表，父进程的信号表等等。而创建进程和创建线程时最主要的不同就是在于 clone_flags 参数的不同，在这里我们就只说一下是否复制内存描述符和所有页表，如果在调用clone() 函数时设置了这个标志，那么创建出来的父子task就会共享页表，也就说他们的内存空间就是一样的，这个task就是我们概念上所理解的线程。

而没有设置这个标志位时，在copy_process() 中复制完task_struct 之后，可以理解为操作系统会为子任务创建一个新的地址空间，将父任务的物理页面全都复制一份给子任务，然后为子任务维护新的页目录，这个创建的task就是我们概念上理解的进程。当然，这只是我们为了方便理解这么说的，实际操作系统并不会直接复制父任务的内存给子任务，而是采取“写时复制的策略”。在copy_process() 之后，操作系统还是会将父任务所在的物理内存页面映射到子任务的地址空间中，但会将父子任务的内存页都标志为只读，两者仍然是共享的同一份物理内存。只有父子任务会对某一页的内存进行写操作时，才会采取实际的复制操作，将要修改的那一页复制给子任务，然后修改对应页表项的基址和权限。

从前面说的来看，其实Linux底层的 do_fork 函数是没有严格区分进程和线程的，仅仅是根据上层传入 clone_flags  参数来决定采取哪些复制策略。如果我们认为 fork() 创建的进程， 而 pthread_create() 创建的是线程，那么两者最主要的区别就是传到底层clone_flags 参数的不同。pthread_create() 掉的是Linux 的clone() 函数，他将clone_flags 标志位设置了很多，包括共享内存空间、共享文件系统信息、共享文件描述符表、信号量列表值、信号处理程序表。而fork() 对 clone_flags 这个参数唯一使用的标志就是 SIGCHLD ，就是子进程终止后发送SIGCHLD信号通知父进程。



#### 1.1.2 在task 调度时，进程和线程的区别：

Linux 中从一个task 切换到另一个task的时候，要进行上下文切换，就是指将当前正在运行的task 的CPU状态保存到内存中的某处，然后再找到下一个要运行的task，将他的保存在内存中的CPU状态恢复到CPU中，让下一task从中断处的指令处继续循行。当操作系统通过调度算法找到下一个要切换的task的时候，就会执行 context_switch() 的函数来进行上下文切换。上下文切换主要涉及到虚拟地址空间和寄存器的切换，Linux在切换地址空间时，会对比prev和next 两个task的mm_struct，这个struct 是保存task 的地址空间相关信息的，如果两者相同，那么不需要切换地址空间，直切寄存器就可以了，如果不同，那么就切换地址空间。

而这里是否切换地址空间就是进程和线程切换的主要求别，因为我们前面所讲，进程会有自己的虚拟地址空间，而线程是没有的。所以从一个进程切换到另一个进程的时候是不需要切内存空间的，而从一个进程中的一个线程切到另一个线程的时候就不需要切内存空间。

#### 1.1.3 进程和线程通信方式的不同：

**进程间的通信方式**：

管道(pipe)

管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。



有名管道 (namedpipe)

有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。



信号量(semaphore)

信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。



消息队列(messagequeue)

消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。



信号 (sinal)

信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。

如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。

如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。





共享内存(shared memory)

共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。





套接字(socket)

套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。



**线程间通信方式：**

参考资料：https://blog.nowcoder.net/n/7571c2a5ef82480380fea53875b8187b?from=nowcoder_improve







## 1.2 虚拟内存

段页式的内存管理方式

（先分别介绍分段和分页）

分段：程序会分为不同的段，包括代码段、数据段等，每个段都有一个段基址，保存在程序的段表中。

分页：分页是指操作系统为进程分配内存时以页为单位进行分配，每页的大小通常为4kb。操作系统会为每个进程保存一个页目录，页目录中保存了所有已分配给进程的页表项。

通过页表将虚拟地址转换为物理地址时，是将虚拟地址的前n位作为页目录的页号，通过页号找到对应的页表项，页表项的前n位是实际物理地址的基址，而虚拟地址的剩余位是偏移量。那么页表项的物理基址+虚拟地址部分的偏移量就是





对于一个全局变量 int a，如何通过a 的虚拟地址找到 a 的物理地址：

1）首先打印出变量 a 的地址；

（在段页式的内存管理方式中，内存的访问是 段基址：线性地址的方式组合出实际的虚拟地址）

2）得到变量a打印出的地址，结合变量的段基址组合出进程地址空间中的虚拟地址；



LDT 在哪里呢？ldtr 寄存器是线索的起点，通过它可以在 GDT（全局描述符表）中找到 LDT 的物理地址。





## 2 Linux 

### 2.1 常用的Linux命令



### 2.2 硬链接与软链接的区别

1. **定义不同**

   ​	软链接又叫符号链接，这个文件包含了另一个文件的路径名。可以是任意文件或目录，可以链接不同文件系统的文件。

   ​	硬链接就是一个文件的一个或多个文件名。把文件名和计算机文件系统使用的节点号链接起来。因此我们可以用多个文件名与同一个文件进行链接，这些文件名可以在同一目录或不同目录。

2. **限制不同**

   ​	硬链接只能对已存在的文件进行创建，不能交叉文件系统进行硬链接的创建；		

   ​	软链接可对不存在的文件或目录创建软链接；可交叉文件系统；		

3. **创建方式不同**

   ​	硬链接不能对目录进行创建，只可对文件创建；		

   ​	软链接可对文件或目录创建；

4. **影响不同**

   ​	删除一个硬链接文件并不影响其他有相同 inode 号的文件。

   ​	删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。











