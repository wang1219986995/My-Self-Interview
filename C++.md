# C++ 面经

## 1 其他





## 1 重点内容

## C++程序的编译过程

1 预处理



2 编译











3 汇编



4 链接





## 1 指针

#### 1.1.21 说说使用指针需要注意什么？

1. 定义指针时，先初始化为NULL。
2. 用malloc或new申请内存之后，应该**立即检查**指针值是否为NULL。防止使用指针值为NULL的内存。
3. 不要忘记为数组和动态内存**赋初值**。防止将未被初始化的内存作为右值使用。
4. 避免数字或指针的下标**越界**，特别要当心发生“多1”或者“少1”操作
5. 动态内存的申请与释放必须配对，防止**内存泄漏**
6. 用free或delete释放了内存之后，立即将指针**设置为NULL**，防止“野指针”



#### 1.1.24 简述const（星号）和（星号）const的区别

```
//const* 是常量指针，*const 是指针常量
int const *a;    //a指针所指向的内存里的值不变，即（*a）不变
int *const a;    //a指针所指向的内存地址不变，即a不变

```



#### 1.1.19 说说C++中函数指针和指针函数的区别。

1. **定义不同** 指针函数本质是一个函数，其返回值为指针。 函数指针本质是一个指针，其指向一个函数。

2. **写法不同**

   ```
   指针函数：int *fun(int x,int y);
   函数指针：int (*fun)(int x,int y);
   ```

3. **用法不同**

```
//指针函数示例
typedef struct _Data{
    int a;
    int b;
}Data;
//指针函数
Data* f(int a,int b){
    Data * data = new Data;
    //...
    return data;
}
int main(){
    //调用指针函数
    Data * myData = f(4,5);
    //Data * myData = static_cast<Data*>(f(4,5));
   //...
}

//函数指针示例
int add(int x,int y){
    return x+y;
}
//函数指针
int (*fun)(int x,int y);
//赋值
fun = add;
//调用
cout << "(*fun)(1,2) = " << (*fun)(1,2) ;
//输出结果
//(*fun)(1,2) =  3

```





## 2 语法

#### 1.1.18 说说const和define的区别。

const用于定义常量；而define用于定义宏，而宏也可以用于定义常量。都用于常量定义时，它们的区别有：

1. const生效于编译的阶段；define生效于预处理阶段。
2. const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。
3. const定义的常量是带类型的；define定义的常量不带类型。因此define定义的常量不利于类型检查。

#### 1.1.22 说说内联函数和函数的区别，内联函数的作用。

1. 内联函数比普通函数多了关键字**inline**
2. 内联函数避免了函数调用的**开销**；普通函数有调用的开销
3. 普通函数在被调用的时候，需要**寻址（函数入口地址）**；内联函数不需要寻址。
  4. 内联函数有一定的限制，内联函数体要求**代码简单**，不能包含复杂的结构控制语句；普通函数没有这个要求。	

**内联函数的作用**：内联函数在调用时，是将调用表达式用内联函数体来替换。避免函数调用的开销。



在使用内联函数时，应注意如下几点： 

1. 在内联函数内不允许用循环语句和开关语句。  如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码,递归函数是不能被用来做内联函数的。内联函数只适合于只有1～5行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，所以也没有必要用内联函数实现。 

2. 内联函数的定义必须出现在内联函数第一次被调用之前。 

   ​

#### 1.1.23 简述C++有几种传值方式，之间的区别是什么？

传参方式有这三种：**值传递、引用传递、指针传递**

1. 值传递：形参即使在函数体内值发生变化，也不会影响实参的值；
2. 引用传递：形参在函数体内值发生变化，会影响实参的值；
3. 指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；



​	值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。

​	代码示例 

```
//代码示例
#include <iostream>
using namespace std;

void testfunc(int a, int *b, int &c){//形参a值发生了改变，但是没有影响实参i的值；但形参*b、c的值发生了改变，影响到了实参*j、k的值
    a += 1;
    (*b) += 1;
    c += 1;
    printf("a= %d, b= %d, c= %d\n",a,*b,c);//a= 2, b= 2, c= 2
}
int main(){
       int i = 1;
    int a = 1;
    int *j = &a;
    int k = 1;
    testfunc(i, j, k);
    printf("i= %d, j= %d, k= %d\n",i,*j,k);//i= 1, j= 2, k= 2
    return 0;
}

```





## 3 内存

#### 1.1.17 说说new和malloc的区别，各自底层实现原理。

1. new是操作符，而malloc是函数。
2. new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。
3. malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。
4. new可以被重载；malloc不行
5. new分配内存更直接和安全。
6. new发生错误抛出异常，malloc返回null

**答案解析**

​	**malloc底层实现：**当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。

​	**new底层实现：**关键字new在调用构造函数的时候实际上进行了如下的几个步骤：

1. 创建一个新的对象
2. 将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）
3. 执行构造函数中的代码（为这个新对象添加属性）
4. 返回新对象

## 4 函数



### 1.1.15 内联函数和宏函数的区别

1. **宏定义不是函数**，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；**而内联函数本质上是一个函数**，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。
2. **宏函数**是在预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 ；**而内联函数**则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率
3. **宏定义**是没有类型检查的，无论对还是错都是直接替换；**而内联函数**在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等

  ​**1、使用时的一些注意事项：**

  - 使用宏定义一定要注意错误情况的出现，比如宏定义函数没有类型检查，可能传进来任意类型，从而带来错误，如举例。还有就是括号的使用，宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性	
- inline函数一般用于比较小的，频繁调用的函数，这样可以减少函数调用带来的开销。只需要在函数返回类型前加上关键字inline，即可将函数指定为inline函数。
- 同其它函数不同的是，最好将inline函数定义在头文件，而不仅仅是声明，因为编译器在处理inline函数时，需要在调用点内联展开该函数，所以仅需要函数声明是不够的。

  ​**2、内联函数使用的条件：**

  - 内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率 的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联： 	
  - （1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 
    - （2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。 
    - 内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动地取消不符合要求的内联。





## 5 面向对象

####  1.3.1 简述什么是面向对象

1. 面向对象是一种编程思想，把一切东西看成是一个个对象，比如人、耳机、鼠标、水杯等，他们各自都有属性，比如：耳机是白色的，鼠标是黑色的，水杯是圆柱形的等等，把这些对象拥有的属性变量和操作这些属性变量的函数打包成一个类来表示

2. 面向过程和面向对象的区别

   ​	面向过程：根据业务逻辑从上到下写代码

   ​	面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程

#### 1.3.2 简述一下面向对象的三大特征

面向对象的三大特征是封装、继承、多态。

1. 封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行 交互。封装本质上是一种管理：我们如何管理兵马俑呢？比如如果什么都不管，兵马俑就被随意破坏了。那么我们首先建了一座房子把兵马俑给封装起来。但是我们目的全封装起来，不让别人看。所以我们开放了售票通 道，可以买票突破封装在合理的监管机制下进去参观。类也是一样，不想给别人看到的，我们使用protected/private把成员封装起来。开放一些共有的成员函数对成员合理的访问。所以封装本质是一种管理。 

2. 继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

   三种继承方式		

   | 继承方式           | private继承   | protected继承   | public继承             |
   | -------------- | ----------- | ------------- | -------------------- |
   | 基类的private成员   | 不可见         | 不可见           | 不可见                  |
   | 基类的protected成员 | 变为private成员 | 仍为protected成员 | 仍为protected成员        |
   | 基类的public成员    | 变为private成员 | 变为protected成员 | 仍为public成员仍为public成员 |

3. 多态：用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。实现多态，有二种方式，重写，重载。



#### 1.3.3 C++ 的重载和重写

**1 区别：**

1. 重写

   ​	是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。


1. 重载

   ​	C++规定在同一作用域中，例如一个类的成员函数之间，多个函数的名称相同，但是各个函数的参数列表（指参数的个数、类型或者顺序）不同时，构成函数重载。	

**2 如何实现** 

1. C++利用命名倾轧（name mangling）技术，来改名函数名，区分参数不同的同名函数。命名倾轧是在编译阶段完成的。

   C++定义同名重载函数：

   ```
   #include<iostream> using namespace std; int func(int a,double b) {  return ((a)+(b)); } int func(double a,float b) {  return ((a)+(b)); } int func(float a,int b) {  return ((a)+(b)); } int main() {  return 0; }
   ```

   ​			![img](https://uploadfiles.nowcoder.com/images/20220225/4107856_1645788124958/5E57B0F4AE72F40057C2EAA16C4DB902)		

   ​	由上图可得，d代表double，f代表float，i代表int，加上参数首字母以区分同名函数。 		

   2. 在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。	

   3. 用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。 
   4. 存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。 
   5. 多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。 
   6. 重写用虚函数来实现，结合动态绑定。
   7. 纯虚函数是虚函数再加上 = 0。
   8. 抽象类是指包括至少一个纯虚函数的类。

     ​	纯虚函数：virtual void fun()=0。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。		



**3 虚函数表**

https://zhuanlan.zhihu.com/p/75172640









## 面试问题临时统计

### 基础语法



1. C++ 虚函数表剖析

2. C++虚函数这是面试初、中级C++职位一个概率95%以上的面试题。一般有以下几种问法：

   1.在有继承关系的父子类中，构建和析构一个子类对象时，父子构造函数和析构函数的执行顺序分
   别是怎样的？
   2.在有继承关系的类体系中，父类的构造函数和析构函数一定要申明为virtual吗？如果不申明为
   virtual会怎样？
   3.什么是C++多态？C++多态的实现原理是什么？
   4.什么是虚函数？虚函数的实现原理是什么？
   5.什么是虚表？虚表的内存结构布局如何？虚表的第一项（或第二项）是什么？
   6.菱形继承(类D同时继承B和C,B和C又继承自A)体系下，虚表在各个类中的布局如何？
   如果类B和类C同时有一个成员变了m,如何在D对象的内存地址上分布的？是否会相互覆
   盖？

![img](https://picx.zhimg.com/v2-dc85c7a1766065f82ce3bf8c00324ba4_r.jpg?source=1940ef5c)



1，enable_share_from_this 是做什么的，请举一个场景说明？

然后就开始聊多线程编程模式、线程安全等问题。我觉得这个问题是一个很好的问题，从语言出发，扩展到工程经验和对编程的理解。而且弱指针确实是c++非常有特色的一个特性。

2，如何实现一个引用计数指针，以及其中要注意的点？

这也是一个比较有内容的问题。大致说了一下方案，面试官又追问了诸如入侵性与非入侵性设计的区别、优劣，以及析构对象时多动态库架构情况下本地堆问题，还有引用计数的多线程安全问题，有锁怎么实现，无锁怎么实现。

3，为什么stl中的内存分配器要设计为一个模板参数而不是一个构造函数参数？





### C++11/14/17

另外，时至今日，你一定要熟悉C++11/14/17常用的语言特性和类库，这里简单地列一下：
·统一的类成员初始化语法与std:initializer list<T>
注解标签(attributes)
·final/override,/=default/=delete语法
·auto关键字
·Range-based循环语法
·结构化绑定
·st!容器新增的实用方法
·std:thread
·线程局部存储thread local
·线程同步原语Qstd:mutex、std:condition variable等
·原子操作类
智能指针类
std::bind/std::function
C++11/14网上的资料已经很多了，C++17的资料不多，重头戏还是C++11引入的咯种实用特
性，这就给读者推荐一本我读过的：
《深入理解C++11:C++11新特性解析与应用》
《深入应用C++11:代码优化与工程级应用》
《C++17完全指南》
,《Cpp17 in Detail》
链接：pan.baidu.com/s/1Mi4lgw.提取a码：n7in
建议购买正版哦。









## 1.1 语言基础

### 1.1.1 简述C++语言的特点

1. C++在C语言基础上引入了**面对对象**的机制，同时也**兼容C语言**。		
  2. C++有三大特性（1）封装。（2）继承。（3）多态；
2. C++生成的代码**质量高**，运行**效率高**，仅比汇编语言慢10%～20%；

3. C++更加安全，增加了const常量、引用、四类cast转换（static_cast、dynamic_cast、const_cast、reinterpret_cast）、智能指针、try—catch等等；

4. C++**可复用性**高，C++引入了**模板**的概念，后面在此基础上，实现了方便开发的标准模板库STL（Standard Template Library）。

5. 同时，C++是**不断在发展**的语言。C++后续版本更是发展了不少新特性，如C++11中引入了nullptr、auto变量、Lambda匿名函数、右值引用、智能指针。

   ​

### 1.1.2 C语言和C++的区别

1. C语言是C++的子集，C++可以很好兼容C语言。但是C++又有很多**新特性**，如引用、auto变量等。		
  2. C++是**面对对象**的编程语言；C语言是**面对过程**的编程语言。
2. C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C++对此增加了不少新特性来**改善安全性**，如const常量、引用、cast转换、智能指针、try—catch等等；
3. C++**可复用性**高，C++引入了**模板**的概念，后面在此基础上，实现了方便开发的标准模板库STL。C++的STL库相对于C语言的函数库**更灵活、更通用**。

### 1.1.3 说说 C++中 struct 和 class 的区别

1. struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的，例如：


```
struct A{  int iNum; // 默认访问控制权限是 public }
 class B{  int iNum; // 默认访问控制权限是 private }
```

2. struct 一般用于描述一个数据结构集合，而 class 是对一个对象数据的封装；

3. 在继承关系中，struct 默认是公有继承，而 class 是私有继承；
  4. class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数，例如：

```
 template<typename T, typename Y> // 可以把typename 换成 class  
 int Func(const T& t, const Y& y) {      //TODO  }
```



### 1.1.4 说说include头文件的顺序以及双引号""和尖括号<>的区别

1. 区别：		

   ​	（1）尖括号<>的头文件是**系统文件**，双引号""的头文件是**自定义文件**。		

   ​	（2）编译器预处理阶段查找头文件的路径不一样。		

   2. 查找路径：

     ​（1）使用尖括号<>的头文件的查找路径：编译器设置的头文件路径-->系统变量。	

     ​（2）使用双引号""的头文件的查找路径：当前头文件目录-->编译器设置的头文件路径-->系统变量。	

### 1.1.5 说说C++与C结构体的区别

​	区别：

​	（1）C的结构体内不允许有函数存在，C++允许有内部成员函数，且允许该函数是虚函数。

​	（2）C的结构体对内部成员变量的访问权限只能是public，而C++允许public,protected,private三种。

​	（3）C语言的结构体是不可以继承的，C++的结构体是可以从其他的结构体或者类继承过来的。

​	（4）C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用。



### 1.1.6 导入C函数的关键字是什么，C++与C编译时有何不同

1. **关键字：**在C++中，导入C函数的关键字是**extern**，表达形式为**extern “C”**， extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按**C语言**的进行编译，而不是C++的。		
  2. **编译区别：**由于C++支持函数重载，因此编译器编译函数的过程中会将函数的**参数类型**也加到编译后的代码中，而不仅仅是**函数名**；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括**函数名**。

```
//extern示例 
//在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译 
extern "C" int strcmp(const char *s1, const char *s2);  
//在C++程序里边声明该函数 
extern "C"{    
#include <string.h> //string.h里边包含了要调用的C函数的声明 
}  
//两种不同的语言，有着不同的编译规则，比如一个函数fun，可能C语言编译的时候为_fun，而C++则是__fun__
```



### 1.1.7 简述C++从代码到可执行二进制文件的过程

​	      C++和C语言类似，一个C++程序从源码到执行文件，有四个过程，**预编译、编译、汇编、链接**。

1. 预编译：这个过程主要的处理操作如下：		

   ​	（1）  将所有的#define删除，并且展开所有的宏定义		

   ​	（2）  处理所有的条件预编译指令，如#if、#ifdef		

   ​	（3）  处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。		

   ​	（4）  过滤所有的注释		

   ​	（5）  添加行号和文件名标识。		

   2. 编译：这个过程主要的处理操作如下：

     ​（1）  词法分析：将源代码的字符序列分割成一系列的记号。	

     ​（2）  语法分析：对记号进行语法分析，产生语法树。	

     ​（3）  语义分析：判断表达式是否有意义。	

     ​（4）  代码优化：	

     ​（5）  目标代码生成：生成汇编代码。	

     ​（6）  目标代码优化：	

2. 汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。

3. 链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。

  链接分为静态链接和动态链接。

  静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。

  ​而动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。

### 1.1.8 说说 static关键字的作用

1. **定义全局静态变量和局部静态变量**：在变量前面加上static关键字。初始化的静态变量会在数据段分配内存，未初始化的静态变量会在BSS段分配内存。直到程序结束，静态变量始终会维持前值。只不过全局静态变量和局部静态变量的作用域不一样；		

  2. **定义静态函数**：在函数返回类型前加上static关键字，函数即被定义为静态函数。静态函数只能在**本源文件**中使用；	

2. 在c++中，**static关键字可以用于定义类中的静态成员变量**：使用静态数据成员，它既可以被当成全局变量那样去存储，但又被隐藏在类的内部。类中的static静态数据成员拥有一块单独的存储区，而不管创建了多少个该类的对象。所有这些对象的静态数据成员都**共享**这一块静态存储空间。

3. 在c++中，**static关键字可以用于定义类中的静态成员函数**：与静态成员变量类似，类里面同样可以定义静态成员函数。只需要在函数前加上关键字static即可。如静态成员函数也是类的一部分，而不是对象的一部分。所有这些对象的静态数据成员都**共享**这一块静态存储空间。

   ​

### 1.1.9 为什么类中的静态成员函数无法访问成员变量？

当调用一个对象的非静态成员函数时，系统会把该对象的起始地址赋给成员函数的this指针。而静态成员函数不属于任何一个对象，因此C++规定静态成员函数没有this指针（划重点，面试题常考）。既然它没有指向某一对象，也就无法对一个对象中的非静态成员进行访问。

### 1.1.10 说说数组和指针的区别

1. 概念：		

   （1）数组：数组是用于储存多个相同类型数据的集合。 数组名是首元素的地址。 		

    （2）指针：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在**内存中的地址**。 指针名指向了内存的首地址。 		

2. 区别：

  （1）**赋值**：同类型指针变量可以相互赋值；数组不行，只能一个一个元素的赋值或拷贝

  （2）**存储方式**：

    数组：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下进行访问的，数组的存储空间，不是在静态区就是在栈上。		

    指针：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确定。		

  （3）**求sizeof**：

  	    数组所占存储空间的内存大小：sizeof（数组名）	

  ​	    在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8。		

  （4）**初始化**：		

```
 // 数组 
 int a[5] = { 0 }; char b[] = "Hello"; 
 // 按字符串初始化，大小为6 
 char c[] = { 'H','e','l','l','o','\0' };   // 按字符初始化 
 int* arr = new int[10];                   // 动态创建一维数组  
 // 指针 
 // 指向对象的指针 
 int* p = new int(0); delete p; 
 // 指向数组的指针 
 int* p1 = new int[10]; delete[] p1; 
 // 指向类的指针： 
 string* p2 = new string; delete p2; 
 // 指向指针的指针（二级指针）
 int** pp = &p; **pp = 10;
```

​ 		（5）指针操作：   

数组名的指针操作		

```
 int a[3][4];   int (*p)[4];  //该语句是定义一个数组指针，指向含4个元素的一维数组 
 p = a;    //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0] 
 p++;          //该语句执行过后，也就是p=p+1；p跨过行a[0][]指向了行a[1][]               
 //所以数组指针也称指向一维数组的指针，亦称行指针。 
 //访问数组中第i行j列的一个元素，有几种操作方式： 
 //*(p[i]+j)、*(*(p+i)+j)、(*(p+i))[j]、p[i][j]。其中，优先级：()>[]>*。
 //这几种操作方式都是合法的。
```

 指针变量的数据操作：		

```
 char *str = "hello,douya!";
 str[2] = 'a';
 *(str+2) = 'b';
 //这两种操作方式都是合法的。

```

### 1.1.11 什么是函数指针，如何定义，有什么使用场景

1. **概念：**函数指针就是**指向函数**的指针变量。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。
2. **定义**形式如下：

```
int func(int a);  
int (*f)(int a);  
f = &func;  

```

1. 函数指针的**应用场景**：**回调**（callback）。我们调用别人提供的 API函数(Application Programming Interface,应用程序编程接口)，称为Call；如果别人的库里面调用我们的函数，就叫Callback。		


```
//以库函数qsort排序函数为例，它的原型如下：
void qsort(void *base,//void*类型，代表原始数组
           size_t nmemb, //第二个是size_t类型，代表数据数量
           size_t size, //第三个是size_t类型，代表单个数据占用空间大小
           int(*compar)(const void *,const void *)//第四个参数是函数指针
          );
//第四个参数告诉qsort，应该使用哪个函数来比较元素，即只要我们告诉qsort比较大小的规则，它就可以帮我们对任意数据类型的数组进行排序。在库函数qsort调用我们自定义的比较函数，这就是回调的应用。

//示例
int num[100];
int cmp_int(const void* _a , const void* _b){//参数格式固定
    int* a = (int*)_a;    //强制类型转换
    int* b = (int*)_b;
    return *a - *b;　　
}
qsort(num,100,sizeof(num[0]),cmp_int); //回调

```

### 	1.1.11 说说静态变量什么时候初始化？

​	对于C语言的全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化。

​	而C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造。

1. **作用域**：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。		

   静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。		

   静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。		

   类静态成员变量：类作用域。		

   2. **所在空间**：都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。

2. **生命周期**：静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。类静态成员变量在静态存储区，当超出类作用域时回收内存。

### 1.1.12 nullptr调用成员函数可以吗？为什么？

能。

原因：因为在**编译时对象**就绑定了**函数地址**，和指针空不空没关系。

```
//给出实例
class animal{
public:
    void sleep(){ cout << "animal sleep" << endl; }
    void breathe(){ cout << "animal breathe haha" << endl; }
};
class fish :public animal{
public:
    void breathe(){ cout << "fish bubble" << endl; }
};
int main(){
    animal *pAn=nullptr;
    pAn->breathe();   // 输出：animal breathe haha
    fish *pFish = nullptr;
    pFish->breathe(); // 输出：fish bubble
    return 0;
}  

```

​	原因：因为在**编译时对象**就绑定了**函数地址**，和指针空不空没关系。pAn->breathe();编译的时候，函数的地址就和指针pAn绑定了；调用breath(*this), this就等于pAn。由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为this=nullptr，运行出错。

### 	1.1.13 什么是野指针，怎么产生的，如何避免？

1. **概念：**野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）		

  2. **产生原因**：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免。

2. **避免办法：**

   ​	（1）初始化置NULL

    	（2）申请内存后判空

    	（3）指针释放后置NULL

    	（4）使用智能指针

   **产生原因**：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免。如：



### 	1.1.14 说说静态局部变量，全局变量，局部变量的特点，以及使用场景

1. **首先从作用域考虑**：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。		

   ​	全局变量：全局作用域，可以通过extern作用于其他非定义的源文件。		

   ​	静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。		

   ​	局部变量：局部作用域，比如函数的参数，函数内的局部变量等等。		

   ​	静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。		

   2. **从所在空间考虑**：除了局部变量在栈上外，其他都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。

2. **生命周期**： 局部变量在栈上，出了作用域就回收内存；而全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。

3. **使用场景**：从它们各自特点就可以看出各自的应用场景，不再赘述。

### 1.1.15 说说内联函数和宏函数的区别

​区别：

1. **宏定义不是函数**，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；**而内联函数本质上是一个函数**，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。		
2. **宏函数**是在预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 ；**而内联函数**则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率
3. **宏定义**是没有类型检查的，无论对还是错都是直接替换；**而内联函数**在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等

```
//宏定义示例
#define MAX(a, b) ((a)>(b)?(a):(b))
MAX(a, "Hello"); //错误地比较int和字符串，没有参数类型检查

//内联函数示例
#include <stdio.h>
inline int add(int a, int b) {
    return (a + b);
}
int main(void) {
    int a;
    a = add(1, 2);
    printf("a+b=%d\n", a);
    return 0;
}
//以上a = add(1, 2);处在编译时将被展开为：a = (a + b);

```

**1、使用时的一些注意事项：**

- 使用宏定义一定要注意错误情况的出现，比如宏定义函数没有类型检查，可能传进来任意类型，从而带来错误，如举例。还有就是括号的使用，宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性		
  - inline函数一般用于比较小的，频繁调用的函数，这样可以减少函数调用带来的开销。只需要在函数返回类型前加上关键字inline，即可将函数指定为inline函数。
- 同其它函数不同的是，最好将inline函数定义在头文件，而不仅仅是声明，因为编译器在处理inline函数时，需要在调用点内联展开该函数，所以仅需要函数声明是不够的。

**2、内联函数使用的条件：**

- 内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率 的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联： 		
  - （1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 
- （2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。 
- 内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动地取消不符合要求的内联。

### 1.1.16 说说运算符i++和++i的区别

**先看到实现代码：** 

```
#include <stdio.h>
int main(){
       int i = 2;
    int j = 2;
    j += i++; //先赋值后加
    printf("i= %d, j= %d\n",i, j); //i= 3, j= 4
    i = 2;
    j = 2;
    j += ++i; //先加后赋值
    printf("i= %d, j= %d",i, j); //i= 3, j= 5
}

```

1. **赋值顺序不同**：++ i 是先加后赋值；i ++ 是先赋值后加；++i和i++都是分两步完成的。		

  2. **效率不同**：后置++执行速度比前置的慢。

2. **i++ 不能作为左值，而++i 可以**：

   ```
   int i = 0;
   int* p1 = &(++i);//正确
   // int* p2 = &(i++);//错误
   ++i = 1;//正确
   // i++ = 1;//错误

   ```

3. 两者都不是原子操作。

### 1.1.17 说说new和malloc的区别，各自底层实现原理。

1. new是操作符，而malloc是函数。		
  2. new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。	
2. malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。
3. new可以被重载；malloc不行
4. new分配内存更直接和安全。
5. new发生错误抛出异常，malloc返回null



​**malloc底层实现：**当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。

​**new底层实现：**关键字new在调用构造函数的时候实际上进行了如下的几个步骤：

1. 创建一个新的对象		
  2. 将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）
2. 执行构造函数中的代码（为这个新对象添加属性）
3. 返回新对象

### 1.1.18 说说const和define的区别。

const用于定义常量；而define用于定义宏，而宏也可以用于定义常量。都用于常量定义时，它们的区别有：

1. const生效于编译的阶段；define生效于预处理阶段。
  2. const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。
2. const定义的常量是带类型的；define定义的常量不带类型。因此define定义的常量不利于类型检查。

### 1.1.19 说说C++中函数指针和指针函数的区别。

1. **定义不同** 指针函数本质是一个函数，其返回值为指针。 函数指针本质是一个指针，其指向一个函数。		

  2. **写法不同**

 ```
 指针函数：int *fun(int x,int y);
 函数指针：int (*fun)(int x,int y);
 ```

3. **用法不同**		

   用法参考答案解析		

```
//指针函数示例
typedef struct _Data{
    int a;
    int b;
}Data;
//指针函数
Data* f(int a,int b){
    Data * data = new Data;
    //...
    return data;
}
int main(){
    //调用指针函数
    Data * myData = f(4,5);
    //Data * myData = static_cast<Data*>(f(4,5));
   //...
}

//函数指针示例
int add(int x,int y){
    return x+y;
}
//函数指针
int (*fun)(int x,int y);
//赋值
fun = add;
//调用
cout << "(*fun)(1,2) = " << (*fun)(1,2) ;
//输出结果
//(*fun)(1,2) =  3

```

### 	1.1.20 说说const int *a, int const *a, const int a, int *const a, const int *const a分别是什么，有什么特点。

```
1. const int a;     //指的是a是一个常量，不允许修改。
2. const int *a;    //a指针所指向的内存里的值不变，即（*a）不变
3. int const *a;    //同const int *a;
4. int *const a;    //a指针所指向的内存地址不变，即a不变
5. const int *const a;   //都不变，即（*a）不变，a也不变

```

### 	1.1.21 说说使用指针需要注意什么？

1. 定义指针时，先初始化为NULL。		
2. 用malloc或new申请内存之后，应该**立即检查**指针值是否为NULL。防止使用指针值为NULL的内存。
3. 不要忘记为数组和动态内存**赋初值**。防止将未被初始化的内存作为右值使用。
4. 避免数字或指针的下标**越界**，特别要当心发生“多1”或者“少1”操作
5. 动态内存的申请与释放必须配对，防止**内存泄漏**
6. 用free或delete释放了内存之后，立即将指针**设置为NULL**，防止“野指针”



### 	1.1.22 说说内联函数和函数的区别，内联函数的作用。

1. 内联函数比普通函数多了关键字**inline**		
  2. 内联函数避免了函数调用的**开销**；普通函数有调用的开销
2. 普通函数在被调用的时候，需要**寻址（函数入口地址）**；内联函数不需要寻址。
3. 内联函数有一定的限制，内联函数体要求**代码简单**，不能包含复杂的结构控制语句；普通函数没有这个要求。

 **内联函数的作用**：内联函数在调用时，是将调用表达式用内联函数体来替换。避免函数调用的开销。

在使用内联函数时，应注意如下几点： 

1. 在内联函数内不允许用循环语句和开关语句。  如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码,递归函数是不能被用来做内联函数的。内联函数只适合于只有1～5行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，所以也没有必要用内联函数实现。 		
 2. 内联函数的定义必须出现在内联函数第一次被调用之前。 

### 1.1.23 简述C++有几种传值方式，之间的区别是什么？

​传参方式有这三种：**值传递、引用传递、指针传递**

1. 值传递：形参即使在函数体内值发生变化，也不会影响实参的值；		
  2. 引用传递：形参在函数体内值发生变化，会影响实参的值；
2. ​指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；



值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。

​代码示例 

```
//代码示例
#include <iostream>
using namespace std;

void testfunc(int a, int *b, int &c){//形参a值发生了改变，但是没有影响实参i的值；但形参*b、c的值发生了改变，影响到了实参*j、k的值
    a += 1;
    (*b) += 1;
    c += 1;
    printf("a= %d, b= %d, c= %d\n",a,*b,c);//a= 2, b= 2, c= 2
}
int main(){
       int i = 1;
    int a = 1;
    int *j = &a;
    int k = 1;
    testfunc(i, j, k);
    printf("i= %d, j= %d, k= %d\n",i,*j,k);//i= 1, j= 2, k= 2
    return 0;
}

```

### 	1.1.24 简述const（星号）和（星号）const的区别

​	**参考回答**

```
//const* 是常量指针，*const 是指针常量
int const *a;    //a指针所指向的内存里的值不变，即（*a）不变
int *const a;    //a指针所指向的内存地址不变，即a不变

```



### 1.1.25 四种类型转换

1、static_cast（静态类型转换）

a:用于类层次结构中基类和派生类指针或引用的转换：

上行转换：派生类转换为基类 ；（安全的）

下行转换：基类转换为派生类；（是不安全的，没有动态类型检查）

b:用于基本数据类型之间的转换
2、dynamic_cast（动态类型转换）

用于类层次间上行和下行的转换，在进行下行转换时会进行动态类型转换是安全的。

3、 const_cast（常量转换）

用来修饰类型的const属性：把常量指针或常量引用转换为非常量指针或非常量引用，并仍然指向原来的对象；把非常量指针或非常量引用转换为常量指针或常量引用，并仍然指向原来的对象；

注意：不能直接对非常量指针或非常量引用的变量使用const_cast操作符。
4、reinterpret_cast（重新解释转换）

万能转换，可以把指针转换成常量（万物皆可转）。





## 1.2 C++内存

### 1.2.1 简述程序内存中的堆与栈

**栈**是由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈。

**堆**由开发人员分配和释放， 若开发人员不释放，程序结束时由 OS 回收，分配方式类似于链表。

两者的区别：

（1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；

（2）空间大小不同。每个进程拥有的栈大小要远远小于堆大小。一般栈的大小为1~8MB不等，而堆的大小是接近虚拟内存的上限的。

（3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。

（4）分配方式不同。堆都是动态分配的，是用malloc函数和new操作符申请的内存。栈有 2 种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由alloca()函数分配，栈的动态分配会在当前函数结束后自动释放，无需手动释放。

（5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持，分配专门的寄存器存放栈的地址，压栈出栈都有专门的汇编指令执行，这使得栈的效率比较高。堆则是由C/C++提供的库函数或运算符来完成申请与释放的，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。

（6）存放内容不同。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。一般情况下，堆顶的一个字节的空间来存放堆的大小，而其他的具体内容是由程序员来填充的。

### 1.2.2 简述C++的内存管理

**程序的内存布局：**

![DB82B157-BAEF-48c9-98EE-081F865D93A4](E:\LearningMaterials\My-Self-Interview\内存分布.png)



如上图，**从低地址到高地址，一个程序由代码段、dat段、bss段、rodata、堆、栈和动态链接库映射区**组成。

1. **data段：**存放程序中已初始化的全局变量和静态变量的一块内存区域。

  2. **bss** 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。

2. **rodata 段**：存放常量数据

3. **代码段**：存放程序执行代码的一块内存区域。

4. 可执行程序在运行时又会多出两个区域：堆区和栈区。

   **堆区：**动态申请内存用。堆从低地址向高地址增长。	

   **栈区**：存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。	

5. **动态链接库映射区，**位于堆和栈之间，用于映射装载动态链接库。



1. **内存分配方式**：

   在C++中，内存分成5个区，他们分别是堆、栈、全局/静态存储区和常量存储区。

   **栈**，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。

   **堆**，由程序员动态分配的内存，即malloc 和 new分配的内存块。	

   **data段：**存放程序中已初始化的全局变量和静态变量的一块内存区域。

   **bss** 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。	

   **rodata 段**：存放常量数据，不允许修改。	

   ​

   ​

   **常见的内存错误及其对策**：	

   ​（1）内存分配未成功，却使用了它。		

   ​（2）内存分配虽然成功，但是尚未初始化就引用它。		

   （3）内存分配成功并且已经初始化，但操作越过了内存的边界。		

   ​（4）忘记了释放内存，造成内存泄露。		

   （5）释放了内存却继续使用它。		

   **对策：**

   ​	（1）定义指针时，先初始化为NULL。	

   ​	（2）用malloc或new申请内存之后，应该**立即检查**指针值是否为NULL。防止使用指针值为NULL的内存。		

   ​	（3）不要忘记为数组和动态内存**赋初值**。防止将未被初始化的内存作为右值使用。		

   ​	（4）避免数字或指针的下标**越界**，特别要当心发生“多1”或者“少1”操作		

   ​	（5）动态内存的申请与释放必须配对，防止**内存泄漏**		

   ​	（6）用free或delete释放了内存之后，立即将指针**设置为NULL**，防止“野指针”		

   ​	（7）使用智能指针。		

   3. **内存泄露及解决办法**：	

     **什么是内存泄露？**	

     简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放；（2）子类继承父类时，父类析构函数不是虚函数。（3）Windows句柄资源使用后没有释放。	

     **怎么检测？**	

     第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。	

     第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。

     第三：使用智能指针。	

     第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。	

   ​

### **1.2.3程序启动的过程**

1. 操作系统首先创建相应的进程并分配私有的进程空间，然后操作系统的加载器负责把可执行文件的数据段和代码段映射到进程的虚拟内存空间中。		
  2. 加载器读入可执行程序的导入符号表，根据这些符号表可以查找出该可执行程序的所有依赖的动态链接库。
2. 加载器针对该程序的每一个动态链接库调用LoadLibrary （1）查找对应的动态库文件，加载器为该动态链接库确定一个合适的基地址。 （2）加载器读取该动态链接库的导入符号表和导出符号表，比较应用程序要求的导入符号是否匹配该库的导出符号。 （3）针对该库的导入符号表，查找对应的依赖的动态链接库，如有跳转，则跳到3 （4）调用该动态链接库的初始化函数
3. 初始化应用程序的全局变量，对于全局对象自动调用构造函数。
4. 进入应用程序入口点函数开始执行。



### 1.2.4 初始化为0的全局变量在bss还是data

​	.bss 段通常是指用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0。



### 1.2.6 什么是内存泄露，如何检测？

**什么是内存泄露？**

​	简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放；（2）子类继承父类时，父类析构函数不是虚函数。（3）Windows句柄资源使用后没有释放。

**怎么检测？**

​	第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。

​	第二：使用智能指针。

​	第三：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。

#### 1.2.7 简述atomic内存顺序

关于C++ std::atomic 与内存序的介绍： https://zhuanlan.zhihu.com/p/539229114

​	有六个内存顺序选项可应用于对原子类型的操作：

1. memory_order_relaxed：在原子类型上的操作以自由序列执行，没有任何同步关系，仅对此操作要求原子性。
  2. memory_order_consume：memory_order_consume只会对其标识的对象保证该对象存储先行于那些需要加载该对象的操作。
2. memory_order_acquire：使用memory_order_acquire的原子操作，当前线程的读写操作都不能重排到此操作之前。
3. memory_order_release：使用memory_order_release的原子操作，当前线程的读写操作都不能重排到此操作之后。
4. memory_order_acq_rel：memory_order_acq_rel在此内存顺序的读-改-写操作既是获得加载又是释放操作。没有操作能够从此操作之后被重排到此操作之前，也没有操作能够从此操作之前被重排到此操作之后。
5. memory_order_seq_cst：memory_order_seq_cst比std::memory_order_acq_rel更为严格。memory_order_seq_cst不仅是一个"获取释放"内存顺序，它还会对所有拥有此标签的内存操作建立一个单独全序。

除非你为特定的操作指定一个顺序选项，否则内存顺序选项对于所有原子类型默认都是memory_order_seq_cst。



### 1.2.9 简述C++中内存对齐的使用场景

内存对齐应用于三种数据类型中：**struct/class/union**

struct/class/union内存对齐原则有四个：

1. 数据成员对齐规则：结构(struct)或联合(union)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。		
  2. 结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部"最宽基本类型成员"的整数倍地址开始存储。(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)。
2. 收尾工作:结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的"最宽基本类型成员"的整数倍。不足的要补齐。(基本类型不包括struct/class/uinon)。
3. sizeof(union)，以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址。



1. **什么是内存对齐？**	

   ​	在C语言中，结构体是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构体、联合体等）的数据单元。在结构体中，**编译器为结构体的每个成员按其自然边界（alignment）分配空间。**各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构体的地址相同。		

    为了使CPU能够对变量进行快速的访问，变量的起始地址应该具有某些特性，**即所谓的“对齐”，比如4字节的int型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除**，也即“对齐”跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。		

    比如在32位cpu下，假设一个整型变量的地址为0x00000004(为4的倍数)，那它就是自然对齐的，而如果其地址为0x00000002（非4的倍数）则是非对齐的。现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。

2. **为什么要字节对齐？**

   ​需要字节对齐的根本原因在于CPU访问数据的效率问题。假设上面整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据，如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。	

    ​而如果变量在自然对齐位置上，则只要一次就可以取出数据。一些系统对对齐要求非常严格，比如sparc系统，如果取未对齐的数据会发生错误，而在x86上就不会出现错误，只是效率下降。	

    各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。	

3. **内存对齐规则**

   ​	每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认 #pragma pack(4)，可以通过预编译命令 #pragma pack(n)，n = 1,2,4,8,16来改变这一系数。

   有效对齐值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫**对齐单位**。 

   了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则：

   (1)  结构体第一个成员的**偏移量（offset）**为0，以后每个成员相对于结构体首地址的 offset 都是**该成员大小与有效对齐值中较小那个**的整数倍，如有需要编译器会在成员之间加上填充字节。

   (3)  **结构体的总大小**为 有效对齐值 的**整数倍**，如有需要编译器会在最末一个成员之后加上填充字节。

4. **字节对齐实例**

    ```
    union example {    int a[5];    char b;    double c;   };   
    int result = sizeof(example);   

    /* 如果以最长20字节为准，内部double占8字节，这段内存的地址0x00000020并不是double的整数倍，只有当最小为0x00000024时可以满足整除double（8Byte）同时又可以容纳int a[5]的大小，所以正确的结果应该是result=24 */  
    struct example {    
    int a[5];    char b;    double c;  
    }test_struct; 
    int result = sizeof(test_struct);   
    /* 如果我们不考虑字节对齐，那么内存地址0x0021不是double（8Byte）的整数倍，所以需要字节对齐，那么此时满足是double（8Byte）的整数倍的最小整数是0x0024，说明此时char b对齐int扩充了三个字节。所以最后的结果是result=32 */  
    struct example {    char b;    double c;    int a;   }test_struct;  
    int result = sizeof(test_struct);
    /* 字节对齐除了内存起始地址要是数据类型的整数倍以外，还要满足一个条件，那就是占用的内存空间大小需要是结构体中占用最大内存空间的类型的整数倍，所以20不是double（8Byte）的整数倍，我们还要扩充四个字节，最后的结果是result=24 */
    ```